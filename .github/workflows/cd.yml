name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

jobs:
  check-ci-status:
    name: Check CI Status
    runs-on: ubuntu-22.04
    if: >-
      github.event_name == 'workflow_dispatch' || 
      github.event.workflow_run.conclusion == 'success'
    steps:
      - name: Get workflow details
        if: github.event_name == 'workflow_run'
        run: |
          echo "CI 파이프라인이 성공적으로 완료되었습니다."
          echo "워크플로우 ID: ${{ github.event.workflow_run.id }}"
          echo "워크플로우 이름: ${{ github.event.workflow_run.name }}"
          echo "브랜치: ${{ github.event.workflow_run.head_branch }}"

      - name: Manual trigger info
        if: github.event_name == 'workflow_dispatch'
        run: echo "CD 파이프라인이 수동으로 실행되었습니다."

  build-and-push-backend:
    name: Build and Push Backend Docker Image
    runs-on: ubuntu-22.04
    needs: check-ci-status
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1 # 최적화: 불필요한 Git 히스토리 가져오지 않음

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./
          file: ./apps/backend/Dockerfile
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/cirrodrive:backend-cache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/cirrodrive:backend-cache,mode=max
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/cirrodrive:backend

  build-and-push-frontend:
    name: Build and Push Frontend Docker Image
    runs-on: ubuntu-22.04
    needs: check-ci-status
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1 # 최적화: 불필요한 Git 히스토리 가져오지 않음

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./
          file: ./apps/frontend/Dockerfile
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/cirrodrive:frontend-cache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/cirrodrive:frontend-cache,mode=max
          secrets: |
            VITE_API_HOST=${{ secrets.APP_PUBLIC_HOST }}
            VITE_API_PORT=8000
            VITE_TOSS_CLIENT_KEY=test_ck_d46qopOB892JAe2jwoQY3ZmM75y0
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/cirrodrive:frontend

  build-and-push-reverse-proxy:
    name: Build and Push Reverse Proxy Docker Image
    runs-on: ubuntu-22.04
    needs: check-ci-status
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1 # 최적화: 불필요한 Git 히스토리 가져오지 않음

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build and push reverse-proxy image
        uses: docker/build-push-action@v5
        with:
          context: ./apps/reverse-proxy
          file: ./apps/reverse-proxy/Dockerfile
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/cirrodrive:reverse-proxy

  database-migration:
    name: database-migration
    runs-on: ubuntu-22.04
    needs: check-ci-status
    environment: production
    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      AUTH_DEFAULT_ADMIN_EMAIL: ${{ secrets.AUTH_DEFAULT_ADMIN_EMAIL }}
      AUTH_DEFAULT_ADMIN_PASSWORD: ${{ secrets.AUTH_DEFAULT_ADMIN_PASSWORD }}
      AUTH_DEFAULT_ADMIN_USERNAME: ${{ secrets.AUTH_DEFAULT_ADMIN_USERNAME }}
    steps:
      - name: Prepare Docker Environment
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: DATABASE_URL,AUTH_DEFAULT_ADMIN_EMAIL,AUTH_DEFAULT_ADMIN_PASSWORD,AUTH_DEFAULT_ADMIN_USERNAME
          script: |
            # 배포 디렉토리 확인 및 생성
            mkdir -p /home/${{ secrets.SERVER_USER }}/cirrodrive-deploy

            cd /home/${{ secrets.SERVER_USER }}/cirrodrive-deploy

            # 현재 브랜치 정보 가져오기
            git fetch origin

            # 현재 워크플로우가 실행된 브랜치로 체크아웃
            CURRENT_BRANCH="${{ github.ref_name }}"
            echo "현재 브랜치로 체크아웃: $CURRENT_BRANCH"

            # 브랜치 체크아웃 (로컬 브랜치가 없으면 생성)
            git checkout -B $CURRENT_BRANCH origin/$CURRENT_BRANCH || {
              echo "브랜치 체크아웃 실패, 기본 브랜치로 fallback"
              git checkout main
            }

            pnpm install
            pnpm run db:push
            pnpm run db:seed

  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-22.04
    needs:
      [
        build-and-push-backend,
        build-and-push-frontend,
        build-and-push-reverse-proxy,
      ]
    environment: production
    steps:
      - name: Prepare Docker Environment
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            # Docker 이미지 최신 버전 가져오기

            echo "Docker 이미지 pull 시작..."

            # 기존 컨테이너 정리
            docker container prune -f || true

            # 네트워크 정리
            docker network prune -f || true

            # 사용하지 않는 볼륨 정리
            docker volume prune -f || true

            # 개별 이미지 pull
            pull_image_with_retry() {
              local image_name=$1
              local max_retries=3
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                echo "이미지 pull 시도 ($((retry_count + 1))/$max_retries): $image_name"
                
                if docker pull "$image_name"; then
                  echo "✅ 성공적으로 이미지를 가져왔습니다: $image_name"
                  return 0
                else
                  echo "❌ 이미지 pull 실패: $image_name"
                  retry_count=$((retry_count + 1))
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "디스크 공간 정리 후 재시도..."
                    # 댕글링 이미지만 삭제
                    docker image prune -f || true
                    sleep 5
                  fi
                fi
              done
              
              echo "❌ 최대 재시도 횟수 초과: $image_name"
              return 1
            }

            # 각 이미지 pull
            pull_image_with_retry "${{ secrets.DOCKERHUB_USERNAME }}/cirrodrive:backend" || { 
              echo "백엔드 이미지 가져오기 최종 실패"; exit 1; 
            }

            pull_image_with_retry "${{ secrets.DOCKERHUB_USERNAME }}/cirrodrive:frontend" || { 
              echo "프론트엔드 이미지 가져오기 최종 실패"; exit 1; 
            }

            pull_image_with_retry "${{ secrets.DOCKERHUB_USERNAME }}/cirrodrive:reverse-proxy" || { 
              echo "리버스 프록시 이미지 가져오기 최종 실패"; exit 1; 
            }

            echo "✅ 모든 Docker 이미지가 성공적으로 업데이트되었습니다"

            # 최종 이미지 확인
            echo "현재 사용 가능한 cirrodrive 이미지:"
            docker images | grep cirrodrive || echo "cirrodrive 이미지를 찾을 수 없습니다"

  deployment:
    name: Deployment
    runs-on: ubuntu-22.04
    needs: [prepare-release, database-migration]
    environment: production
    env:
      NODE_ENV: production
      APP_PUBLIC_HOST: ${{ secrets.APP_PUBLIC_HOST }}
      APP_BACKEND_PORT: 8000
      APP_FRONTEND_PORT: 3000
      AUTH_JWT_SECRET: ${{ secrets.AUTH_JWT_SECRET }}
      AUTH_DEFAULT_ADMIN_USERNAME: ${{ secrets.AUTH_DEFAULT_ADMIN_USERNAME }}
      AUTH_DEFAULT_ADMIN_PASSWORD: ${{ secrets.AUTH_DEFAULT_ADMIN_PASSWORD }}
      AWS_REGION: ap-northeast-2
      AWS_SES_SOURCE_EMAIL: ${{ secrets.AWS_SES_SOURCE_EMAIL }}
      AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
      AWS_CLOUDFRONT_DOMAIN: ${{ secrets.AWS_CLOUDFRONT_DOMAIN }}
      AWS_CLOUDFRONT_KEY_PAIR_ID: ${{ secrets.AWS_CLOUDFRONT_KEY_PAIR_ID }}
      AWS_CLOUDFRONT_PRIVATE_KEY: ${{ secrets.AWS_CLOUDFRONT_PRIVATE_KEY }}
      AWS_CLOUDFRONT_EXPIRES_IN_SECONDS: 3600
      PAYMENT_TOSS_SECRET_KEY: ${{ secrets.PAYMENT_TOSS_SECRET_KEY }}
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
    steps:
      - name: Deploy and Start Containers
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: NODE_ENV,APP_BACKEND_PORT,APP_FRONTEND_PORT,APP_PUBLIC_HOST,AUTH_JWT_SECRET,AUTH_DEFAULT_ADMIN_USERNAME,AUTH_DEFAULT_ADMIN_PASSWORD,AWS_REGION,AWS_SES_SOURCE_EMAIL,AWS_S3_BUCKET,AWS_CLOUDFRONT_DOMAIN,AWS_CLOUDFRONT_KEY_PAIR_ID,AWS_CLOUDFRONT_PRIVATE_KEY,AWS_CLOUDFRONT_EXPIRES_IN_SECONDS,PAYMENT_TOSS_SECRET_KEY,DATABASE_URL
          script: |
            # 작업 디렉토리로 이동
            cd /home/${{ secrets.SERVER_USER }}/cirrodrive-deploy

            # Docker 컨테이너 재시작
            pnpm run docker:down
            pnpm run docker:up || { echo "Docker 컨테이너 시작 실패"; exit 1; }

  validate-deployment:
    name: Validate Deployment
    runs-on: ubuntu-22.04
    needs: deployment
    environment: production
    steps:
      - name: Wait for containers to initialize
        run: sleep 20

      - name: Check Container Health Status
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            echo "컨테이너 상태 확인 중..."

            # 백엔드 컨테이너 상태 확인
            BACKEND_HEALTH=$(docker inspect --format='{{.State.Health.Status}}' cirrodrive-backend)
            echo "백엔드 컨테이너 상태: $BACKEND_HEALTH"

            # 프론트엔드 컨테이너 상태 확인
            FRONTEND_HEALTH=$(docker inspect --format='{{.State.Health.Status}}' cirrodrive-frontend)
            echo "프론트엔드 컨테이너 상태: $FRONTEND_HEALTH"

            # 상태 검증
            if [ "$BACKEND_HEALTH" != "healthy" ] || [ "$FRONTEND_HEALTH" != "healthy" ]; then
              echo "컨테이너가 정상 상태가 아닙니다!"
              
              if [ "$BACKEND_HEALTH" != "healthy" ]; then
                echo "백엔드 컨테이너 로그:"
                docker logs cirrodrive-backend --tail 100
              fi
              
              if [ "$FRONTEND_HEALTH" != "healthy" ]; then
                echo "프론트엔드 컨테이너 로그:"
                docker logs cirrodrive-frontend --tail 100
              fi
              
              exit 1
            fi

            echo "모든 컨테이너가 정상 상태입니다!"

            # 컨테이너가 실행 중인지 로그 확인
            docker ps -a | grep cirrodrive

  notify-success:
    name: Notify Success
    runs-on: ubuntu-22.04
    needs: validate-deployment
    env:
      APP_PUBLIC_HOST: cirrodrive.kro.kr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Get commit info
        id: commit-info
        run: |
          echo "commit_sha=$(git log -1 --pretty=%h)" >> $GITHUB_OUTPUT

      - name: Get deployment details
        id: deployment-details
        run: |
          # 현재 시간 (KST)
          NOW=$(TZ=Asia/Seoul date +"%Y-%m-%d %H:%M:%S %Z")
          echo "deployment_time=$NOW" >> $GITHUB_OUTPUT
          echo "workflow_url=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_OUTPUT

      - name: Notify Discord Success
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK_URL }}
          status: success
          title: "🚀 배포 성공"
          description: |
            **환경:** Production
            **배포 시간:** ${{ steps.deployment-details.outputs.deployment_time }}
            **URL:** http://${{ env.APP_PUBLIC_HOST }}
            **커밋:** [${{ steps.commit-info.outputs.commit_sha }}](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})
          color: 3066993
          url: ${{ steps.deployment-details.outputs.workflow_url }}
          username: GitHub Actions
          avatar_url: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png

  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-22.04
    needs: validate-deployment
    if: failure()
    env:
      APP_PUBLIC_HOST: cirrodrive.kro.kr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Get commit info
        id: commit-info
        run: |
          echo "commit_sha=$(git log -1 --pretty=%h)" >> $GITHUB_OUTPUT

      - name: Get deployment details
        id: deployment-details
        run: |
          # 현재 시간 (KST)
          NOW=$(TZ=Asia/Seoul date +"%Y-%m-%d %H:%M:%S %Z")
          echo "deployment_time=$NOW" >> $GITHUB_OUTPUT
          echo "workflow_url=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_OUTPUT

      - name: Notify Discord Failure
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK_URL }}
          status: failure
          content: "@here 배포에 실패했습니다! 긴급 확인이 필요합니다."
          title: "❌ 배포 실패"
          description: |
            **환경:** Production
            **배포 시간:** ${{ steps.deployment-details.outputs.deployment_time }}
            **URL:** http://${{ env.APP_PUBLIC_HOST }}
            **커밋:** [${{ steps.commit-info.outputs.commit_sha }}](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})
          color: 15158332
          url: ${{ steps.deployment-details.outputs.workflow_url }}
          username: GitHub Actions
          avatar_url: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png
